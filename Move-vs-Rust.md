# 智能合约开发——Move vs. Rust

深入研究 Move，一种用于智能合约开发的新颖编程语言，以及它与 Solana 上使用的现有基于 Rust 的模型的比较。
![](https://github.com/coming-chat/Move-white-paper/blob/main/Solidity%20VS%20Move.jpeg)

## 1. 介绍

最近几周和几个月，围绕 Aptos 和 Sui、新兴的高性能 L1 以及这些新链不可或缺的 Move 智能合约编程语言引起了很多关注。 一些开发人员已经开始积极转向 Move，他们发誓这是智能合约开发的未来，而另一些开发人员则有点谨慎，他们认为 Move 只是另一种智能合约编程语言，从根本上说，它并没有提供比现有编程模型更多的功能。 加密货币投资者还想知道这些新的 L1 有什么特别之处，以及它们如何与 Solana 相抗衡，后者目前是高性能 L1 类别的主要参与者，尤其是使用 Rust 作为智能合约编程的基础。

但是到目前为止，我们所看到的讨论并没有深入到充分理解这项新技术给我们带来的必要深度。 这在讨论的两端都是正确的——Move 怀疑论者淡化了 Move 而没有充分理解它的一些更微妙（但非常重要）的方面，而 Move 粉丝则称赞 Move 没有尽头，但未能充分阐明究竟是什么让它如此 伟大的。 这留下了一个很大的中间立场和很多模棱两可的地方，因此一直在关注这个讨论的外部旁观者、加密货币开发人员和投资者无法自信地形成他们的意见。

我最近对 Move 进行了深入研究，并在 Solana 上拥有智能合约开发经验 在这个讨论之外。

在本文中，我将深入探讨 Move、其新颖的编程模型、Sui 区块链以及它如何利用 Move 的功能，以及它与 Solana 及其编程模型的比较。

为了突出 Move 的特性，我将 Solana/Rust 与 Sui/Move 进行比较。我这样做的主要原因是，当您将某件事与您已经熟悉的另一件事进行比较而不是尝试自己理解它时，更容易理解它。值得注意的是，Move 还有其他版本，例如 Aptos Move，它们在某些事情上略有不同。本文的重点不是讨论 Move 不同版本之间的细微差别，而是展示 Move 的一般优势以及它与 Solana 编程模型的比较，因此为简单起见，我决定只使用一种版本（ Sui Move) 通篇。因此，我在本文中介绍的某些 Move 概念（即对象和相关功能）仅适用于 Move 的 Sui 版本，而不适用于其他版本。虽然 Move 的其他版本不一定具有这些概念，但它们使用不同的机制（例如全局存储）实现相同的功能。但即便如此，本文中讨论的所有主要 Move 优势都适用于所有 Move 集成（原生支持 Move 字节码），包括 Aptos。我特别选择 Sui 的原因很简单，因为我对它更熟悉，而且我觉得它更直观，更容易以文章的形式呈现。

再一次，尽管我在本文中对 Solana 和 Sui 进行了比较，但我的意图并不是要给任何人或任何事情蒙上阴影，而只是强调这些技术的不同方面以及它们的各种好处和权衡，以便于理解。

## 2. solana 编程模型

为了充分理解本文中的要点，需要对 Solana 编程模型有一定的了解。 如果您不熟悉 Solana 的编程模型，我建议您阅读我关于 Solana 智能合约编程的文章，其中涵盖了遵循此模型所需的所有概念。

为了快速复习，我也将在这里做一个简短的总结。 如果您已经熟悉 Solana 的编程模型，则可以跳过本章。

在 Solana 上，程序（智能合约）是无状态的，因为它们不能自行访问（读取或写入）在整个交易过程中持续存在的任何状态。 要访问或保持状态，程序需要使用帐户。 每个账户都有一个唯一的地址（Ed25519 密钥对的公钥），可以存储任意数据。

我们可以将 Solana 的帐户空间视为全局键值存储，其中键是帐户地址（公钥），值是帐户数据。 然后程序通过读取和修改其值在此键值存储之上运行。

账户有所有权的概念。 每个帐户由一个（并且只有一个）程序拥有。 当帐户归程序所有时，程序可以更改其数据。 程序不允许改变他们不拥有的帐户（但允许从中读取）。 这些检查是由运行时动态完成的，通过比较程序执行前后的帐户状态，如果发生非法突变，则交易失败。

每个账户还有一个与之关联的私钥（对应的公钥是它的地址），有权访问该私钥的用户可以用它签署交易。 使用这种机制，我们在 Solana 智能合约中实现了权限和所有权功能——例如 为了访问某些资金，智能合约可以要求用户提供必要的签名。

在其他进行程序调用时，客户端需要指定该程序在调用期间将访问哪些帐户。 这样交易处理运行时可以调度非重叠交易并行执行，同时保证数据一致性。 这是 Solana 实现高吞吐量的设计特点之一。

程序可以通过 CPI 调用来调用其他程序。 这些调用的工作方式与来自客户端的调用几乎相同——调用程序需要指定被调用程序将访问的帐户，并且被调用程序将执行所有相同的输入检查，就好像它是从客户端调用的一样（ 它不信任调用程序）。

PDA 帐户是一种特殊的帐户，它使程序能够在不拥有或存储私钥的情况下提供帐户签名。 PDA 保证只有为其生成 PDA 的程序才能为其创建签名（而不是其他用户和程序）。 当一个程序需要通过 CPI 调用与另一个程序交互并提供权限（例如，实现一个保管库）时，这很有用。 PDA 保证除了程序之外没有人可以直接访问程序的资源。 PDA 也可用于在确定的地址创建帐户。

这些是 Solana 上安全智能合约编程的基本构建块。 同样，如果您觉得这些概念中的任何一个不清楚，我强烈建议您阅读我关于 Solana 智能合约编程的文章，该文章更深入地介绍了这些（和其他内容）中的每一个。

在某种程度上，您可以将 Solana 程序视为操作系统中的程序，将帐户视为文件，任何人都可以在其中自由执行任何程序，甚至部署自己的程序。 当程序（智能合约）运行时，它们将读取和写入文件（帐户）。 所有文件都可供所有程序读取，但只有对文件具有所有权权限的程序才能写入。 程序也可以执行其他程序，但它们不以任何方式相互信任——无论谁执行程序，它都需要假设输入是潜在的对抗性的。 由于任何人都可以在全球范围内访问此操作系统，因此将本机签名验证支持添加到程序中，以便为用户启用权限和所有权功能……这不是一个完美的类比，但它是一个有趣的类比。

## 3. Move 编程模型

在 Move 中，智能合约作为模块发布。 模块由函数和自定义类型（结构）组成。 结构由可以是原始类型（u8、u64、bool…）或其他结构的字段组成。 函数可以调用其他函数——可以在同一个模块中，也可以在其他模块中（如果它们是公开的）。

将其放在 Solana 的上下文中，就好像所有智能合约都作为模块发布在单个程序中。 这意味着所有智能合约（模块）都包含在同一类型系统中，并且可以直接相互调用，而无需通过中间 API 或接口。 这是非常重要的，其含义将在整篇文章中详细讨论。

## 3.1 对象

在我们继续之前，重要的是要注意以下对象概念特定于 Move 的 Sui 变体，并且在 Move 的其他集成中可能会略有不同（例如 Aptos 或 Diem/core Move）。 即便如此，在其他 Move 版本中，也有类似的解决方案可以实现相同的目标（状态持久性），但并不太相似。 我在这里介绍 Sui 对象的主要原因是因为本文后面的代码示例基于 Move 的 Sui 版本，还因为对象比例如对象更易于理解。 核心 Move 中的全局存储机制。 但重要的是，本文讨论的 Move 的所有主要优点都适用于所有 Move 集成（原生支持 Move 字节码），包括 Aptos。 要了解 Sui 和 Aptos 版本的不同之处，[我们为什么创建 Sui Move](https://sui.io/resources-move/why-we-created-sui-move/)文章和 [Move on Aptos](https://aptos.dev/guides/move-guides/move-on-aptos/) 文档页面是一个好的开始。

对象是由运行时存储的结构实例，并跨交易保持状态。

存在三种不同类型的对象（在 Sui 中）：
- 拥有者对象
- 共享对象
- 不可更改对象

拥有者对象是属于用户的对象。 只有拥有该对象的用户才能在交易中使用它。 所有权元数据是完全透明的并由运行时处理。 它是使用公钥加密实现的——每个拥有的对象都与一个公钥相关联（存储在运行时对象的元数据中），并且任何时候你想在交易中使用一个对象，你都需要提供相应的签名（现在支持 Ed25519 ECDSA 和 K-of-N 多重签名支持即将推出）。

共享对象类似于拥有对象，但它们没有与之关联的所有者。 因此，您不必拥有任何私钥就可以在交易中使用它们（任何人都可以使用它们）。 任何拥有者对象都可以（由其所有者）共享，并且一旦共享了一个对象，它将永远保持共享状态——它永远不会被转移或再次成为拥有的对象。

不可更改对象： 一旦一个对象被标记为不可变，它的字段就不能再被修改。 与共享对象类似，它们没有所有者，任何人都可以使用。
