# Move 语言中文白皮书
## 翻译自： [Move language whiter paper](https://github.com/coming-chat/Move-white-paper/blob/main/Move%202020-05-26.pdf)

## Move: 一种使用可编程**resources**的语言

Sam Blackshear, Evan Cheng, David L. Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott, Shaz Qadeer, Rain, Dario Russi, Stephane Sezer, Tim Zakian, Runtian Zhou * 合著

译者：GG@ComingChat

读者须知：本报告在协会发布白皮书 v2.0 之前发布，其中包括对 Libra 支付系统的多项关键更新。已删除过时的链接，但除此之外，本报告尚未修改以包含更新，应在该上下文中阅读。


## 摘要
我们为 Libra 区块链[1][2] 提供了一种安全且灵活的编程语言，它的名字叫做Move。Move也是一种可执行的字节码语言，用于实现自定义交易和智能合约。

Move 的关键特性是能够使用受线性逻辑启发的语义定义自定义**resources**类型 [3]：**resources**永远不能被复制或隐式丢弃，只能在程序存储位置之间移动。这些安全保证由 Move 的类型系统静态强制执行。虽然有这些特殊保护，但不会局限resource这一类型的功能，它可以像传统的类型一样，可以存储在数据结构中，也可以作为参数传递。

**First-class resources**是一个非常笼统的概念，程序员不仅可以使用它来实现安全的数字资产，还可以编写正确的业务逻辑来包装资产以及对数值不同权限的访问和操作。
Move 的安全性和表现力使我们能够在 Move 中实现 Libra 协议的重要部分，包括 Libra 币、交易处理和验证者管理。

## 1.介绍

互联网和移动宽带的出现连接了全球数十亿人，提供了获取知识、免费通信和广泛的低成本、更便捷的服务。
这种连通性也使更多人能够访问金融生态系统。然而，尽管取得了这些进展，但对于最需要金融服务的人来说，获得金融服务的机会仍然有限。

Libra的使命是改变这种状况 [1]。 在本文中，我们介绍了 Move，这是一种新的编程语言，用于在 Libra 协议中实现自定义交易逻辑和智能合约 [2]。为了介绍move，我们分以下例举的几个章节来说明：

1. 描述在区块链上表示数字资产的挑战（第 2 节）。
2. 解释我们的 Move 设计如何应对这些挑战（第 3 节）。
3. 对 Move 的关键特性和编程模型（第 4 节）给出一个面向示例的概述。
4. 深入研究语言和虚拟机设计的技术细节（第 5 节、第 6 节和附录 A）。
5. 最后总结我们在 Move 上取得的进展，描述我们的语言发展计划，并概述我们在 Libra 区块链上支持第三方 Move 代码的路线图（第 7 节）。

本文适用于两种不同的读者：
- 可能不熟悉区块链系统的编程语言研究人员。 我们鼓励这些读者从头到尾阅读这篇论文，但我们警告说，我们有时可能会在没有为不熟悉的读者提供足够背景的情况下提及区块链概念。 在深入研究本文之前阅读 [2] 会有所帮助，但这不是必需的。
- 可能不熟悉编程语言研究但有兴趣了解 Move 语言的区块链开发人员。 我们鼓励这些读者从第 3 节开始。我们警告第 5 节、第 6 节和附录 A 包含一些可能不熟悉的编程语言术语和形式化。

## 2. 在区块链上管理数字资产
我们将首先在抽象层面简要解释区块链，以帮助读者理解像 Move 这样的“区块链编程语言”所扮演的角色。 此讨论有意省略了区块链系统的许多重要细节，以便专注于从语言角度来看相关的功能。

### 2.1. 区块链 概要
区块链是一个复制的状态机 [4][5]。 系统中的复制器称为验证节点。 系统用户将交易发送给验证者。 每个验证节点都了解如何执行交易以将其内部状态机从当前状态转换为新状态。
验证节点利用他们对交易执行的共同理解来遵循共识协议来共同定义和维护复制状态。
- 验证节点从相同的初始状态开始。
- 验证节点选择执行相同的交易顺序。
- 执行交易产生确定性的状态转换。

验证阶节点执行以上步骤后，会就下一个状态达成一致。 重复应用此方案允许验证节点在继续就当前状态达成一致的同时处理交易。

请注意，共识协议和状态转换组件对彼此的实现细节不敏感。 只要共识协议确保交易之间的总顺序并且状态转换方案是确定性的，组件就可以和谐地交互。

### 2.2. 在一个开放的系统中进行数字资产编码

像 Move 这样的区块链编程语言的作用是决定如何表示转换和状态。为了支持丰富的金融基础设施，Libra 区块链的状态必须能够在给定的时间点对数字资产的所有者进行编码。此外，状态转换应该允许资产转移。
区块链编程语言的设计还必须考虑另一个考虑因素。与其他公有链一样，Libra 区块链是一个开放系统。 任何人都可以查看当前的区块链状态或向验证节点提交交易（即提议状态转换）。传统web2行业，用于管理数字资产的软件（例如银行软件）在具有特殊管理控制的封闭系统中运行。 在公有链中，所有参与者都是平等的。 参与者可以提出她喜欢的任何状态转换，但系统并不应该允许所有状态转换。 例如，Alice 可以自由提议转移 Bob 拥有的资产的状态转换。 状态转换函数必须能够识别这个状态转换是无效的并且拒绝它。

在开放软件系统中选择编码数字资产所有权的转换和状态表示具有挑战性。 特别是，实物资产有两个属性难以在数字资产中编码：
- Scarcity：控制系统中的资产供应， 禁止复制现有资产，创建新资产为特权操作。
- 访问控制：系统中的参与者应该能够通过访问控制策略保护她的资产。

为了直观表现，我们将在一系列关于状态转换表示的 strawman proposal 实例中看到这些问题是如何出现的。我们将假设一个区块链跟踪称为 StrawCoin 的单一数字资产。区块链状态 G 被构造为一个键值存储，它将用户身份（用加密公钥表示）映射到对每个用户持有的 StrawCoin 进行编码的自然数值。提案由一个交易脚本组成，该脚本将使用给定的评估规则进行评估，生成一个更新以应用于全局状态。我们将写 G[𝐾] := 𝑛 来表示用值 𝑛 更新存储在全局区块链状态中键 𝐾 处的自然数。

每个提案的目标是设计一个系统，该系统具有足够的表达能力，允许 Alice 将 StrawCoin 发送给 Bob，但又受到足够的约束，以防止任何用户违反Scarcity或访问控制属性。 这些提案并没有试图解决重放攻击等安全问题 [6]，这些问题很重要，但与我们关于Scarity和访问控制的讨论无关。

Scarcity. 最简单的提案是直接在交易脚本中对状态的更新进行编码：

   |交易脚本格式      |         迭代规则 |
   |:-------:       | :------------:  |
   |<K,n>           |      G[K] := n  |
   
这种表示可以编码从 Alice 向 Bob 发送 StrawCoin。 但它有几个严重的问题。 一方面，这个提议并没有强制StrawCoin的Scarcity。 通过发送交易⟨Alice, 100⟩，Alice 可以“凭空”给自己尽可能多的 StrawCoin。 因此，Alice 发送给Bob的StrawCoin实际上毫无价值，因为Bob可以很容易地为自己创造这些代币。
